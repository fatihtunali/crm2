Top risks & immediate fixes

Pagination & sorting missing (every list endpoint)
Risk: large result sets, UI lag, DB strain.
Fix: add page, page_size (bounded), sort, q/search consistently; respond with a wrapper that includes data, page, page_size, total.

Status codes & response shapes inconsistent
Risk: clients branch per endpoint; hard to cache & test.
Fix: use 201 Created for POST, 200 OK for GET, 204 No Content for DELETE (or 200 with body for soft-delete), 400/404/409/422 as needed. Standardize a Problem error schema.

Money & decimals
Risk: floating-point bugs.
Fix: represent money as integer minor units (e.g., amount_minor: integer, currency: ISO-4217) + helper in docs. Keep totals server-calculated.

PUT vs PATCH
Risk: destructive overwrites, race conditions.
Fix: use PATCH for partial updates; PUT only for full replace. Most of your “update” routes should be PATCH.

Idempotency & concurrency
Risk: duplicate records/payments via retries.
Fix: require Idempotency-Key for POST that creates side-effects (quotes, invoices, payments). Support If-Match/ETags for update concurrency.

Multi-tenancy & organization scope
Risk: cross-tenant leakage.
Fix: require an X-Tenant-Id header (or infer from JWT) and document it globally. Add organization_id where needed (Providers, Hotels, etc.) and enforce via policy.

Supplier modeling & “Provider” confusion
Risk: messy joins, hard reporting.
Fix: normalize: Provider = legal entity; Supplier = polymorphic offering tied to a provider (Hotel/Guide/Vehicle/Restaurant/EntranceFee/ExtraExpense/Transfer/TourPackage). In spec, use oneOf with a discriminator, and ensure each concrete supplier includes provider_id.

Quotation → Booking lifecycle is incomplete
Risk: finance breaks and invoice timing confusion.
Fix: add /api/bookings and explicitly define the transition (acceptance freezes exchange rate; generates receivable invoice(s) and payable(s) drafts).

Exchange rates & locking not expressed
Risk: incorrect P&L when rates move.
Fix: add /api/finance/exchange-rates and a locked_exchange_rate on bookings; document that quotes adopt the most recent rate on acceptance.

Search consistency
Risk: duplicated logic across many resources.
Fix: give every GET /… list endpoint a search param and a consistent sort/filter grammar. Keep /api/suppliers/search as a cross-type federated search.

Design & spec corrections (concrete)
1) Global components to add
components:
  parameters:
    Page:
      in: query
      name: page
      schema: { type: integer, minimum: 1, default: 1 }
    PageSize:
      in: query
      name: page_size
      schema: { type: integer, minimum: 1, maximum: 200, default: 25 }
    Sort:
      in: query
      name: sort
      description: "Comma list of fields; prefix with '-' for desc"
      schema: { type: string, example: "-created_at,hotel_name" }
    StatusFilter:
      in: query
      name: status
      schema:
        type: string
        enum: [all, active, inactive]
    Search:
      in: query
      name: search
      schema: { type: string }
  headers:
    IdempotencyKey:
      schema: { type: string }
      description: "Idempotency key for safely retrying POST/PUT/PATCH"
  securitySchemes:
    bearerAuth:
      type: http
      scheme: bearer
      bearerFormat: JWT
  schemas:
    Problem:
      type: object
      required: [type, title, status]
      properties:
        type: { type: string, format: uri }
        title: { type: string }
        status: { type: integer }
        detail: { type: string }
        instance: { type: string, format: uri }
    Money:
      type: object
      required: [amount_minor, currency]
      properties:
        amount_minor:
          type: integer
          description: "Amount in minor units (e.g., cents, kuruş)"
        currency:
          type: string
          description: "ISO-4217"
          example: "EUR"
    PageMeta:
      type: object
      properties:
        page: { type: integer }
        page_size: { type: integer }
        total: { type: integer }
    PagedResponse:
      type: object
      properties:
        data: { type: array, items: { } } # to be overridden with allOf
        meta: { $ref: '#/components/schemas/PageMeta' }

2) Standardize list endpoints (example: Hotels)
/api/hotels:
  get:
    tags: [Suppliers]
    summary: List hotels
    parameters:
      - $ref: '#/components/parameters/Page'
      - $ref: '#/components/parameters/PageSize'
      - $ref: '#/components/parameters/Sort'
      - $ref: '#/components/parameters/StatusFilter'
      - name: city
        in: query
        schema: { type: string }
      - $ref: '#/components/parameters/Search'
    responses:
      '200':
        description: Paged hotels
        content:
          application/json:
            schema:
              allOf:
                - $ref: '#/components/schemas/PagedResponse'
                - type: object
                  properties:
                    data:
                      type: array
                      items: { $ref: '#/components/schemas/Hotel' }
      '400': { $ref: '#/components/schemas/Problem' }

3) Create vs update vs delete semantics (example: Hotels)
  post:
    summary: Create hotel
    security: [{ bearerAuth: [] }]
    requestBody:
      required: true
      content:
        application/json:
          schema:
            required: [hotel_name, city]
            properties:
              hotel_name: { type: string }
              city: { type: string }
              google_place_id: { type: string }
              rating: { type: number, format: float }
              provider_id: { type: integer, format: int64, nullable: true }
    parameters: []
    responses:
      '201':
        description: Created
        headers:
          Location:
            schema: { type: string }
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/Hotel'
  patch:
    summary: Patch hotel
    requestBody:
      required: true
      content:
        application/json:
          schema:
            properties:
              hotel_name: { type: string }
              city: { type: string }
              status: { type: string, enum: [active, inactive] }
              provider_id: { type: integer, nullable: true }
    responses:
      '200': { description: Updated, content: { application/json: { schema: { $ref: '#/components/schemas/Hotel' }}}}
  delete:
    summary: Archive hotel (soft delete)
    responses:
      '204': { description: Archived }


Notes:

Prefer path-param for specific resources (/api/hotels/{id} for GET/patch/delete), not body-param id for update/delete.

Use 201 + Location on creation and return the created resource.

4) Payment & invoice data types

Your invoices currently use number/decimal. Switch to Money:

Invoice:
  type: object
  properties:
    id: { type: integer, format: int64 }
    quotation_id: { type: integer, format: int64 }
    invoice_type: { type: string, enum: [receivable, payable] }
    invoice_number: { type: string }
    amount: { $ref: '#/components/schemas/Money' }
    status: { type: string, enum: [pending, paid, overdue, cancelled] }
    due_date: { type: string, format: date }
    paid_date: { type: string, format: date, nullable: true }


Similarly, for Transfer.price_oneway/price_roundtrip, ExtraExpense.unit_price, Quotation.total_price: adopt Money.

5) Booking lifecycle & exchange-rate locking (add)

Add Booking resource:

Booking:
  type: object
  properties:
    id: { type: integer }
    quotation_id: { type: integer }
    locked_exchange_rate:
      type: number
      format: decimal
      description: "TRY per EUR at acceptance timestamp"
    currency: { type: string, example: "EUR" }
    status: { type: string, enum: [confirmed, cancelled] }
    created_at: { type: string, format: date-time }


Endpoints:

/api/bookings:
  post:
    summary: Create booking from accepted quotation
    parameters:
      - name: quotation_id
        in: query
        required: true
        schema: { type: integer }
    responses:
      '201': { description: Created, content: { application/json: { schema: { $ref: '#/components/schemas/Booking' }}}}

 /api/finance/exchange-rates:
  get:
    summary: List known exchange rates (TRY↔EUR)
  post:
    summary: Upsert an exchange rate
    headers: { Idempotency-Key: { $ref: '#/components/headers/IdempotencyKey' } }


Rule (document it): when a quotation transitions to accepted, the server creates a booking and freezes locked_exchange_rate = last_rate_at(acceptance_time). This rate is used to compute vendor TRY → EUR for P&L.

6) Providers vs suppliers (clarify modeling)

Keep Provider (legal company) separate.

For each supplier entity, ensure provider_id is required (not nullable) unless you have a strong reason; otherwise finances and auditing get muddy.

Consider a federated endpoint:

/api/suppliers:
  get:
    summary: List suppliers across types
    parameters: [Page, PageSize, Sort, Search, {name: type, in: query, schema: {enum: [hotel, guide, vehicle, restaurant, entrance_fee, extra_expense, transfer, tour_package]}}]


…and a discriminator schema if you want a single collection:

Supplier:
  oneOf:
    - $ref: '#/components/schemas/Hotel'
    - $ref: '#/components/schemas/Guide'
    # ...
  discriminator:
    propertyName: supplier_type
    mapping:
      hotel: '#/components/schemas/Hotel'
      guide: '#/components/schemas/Guide'
      # ...

7) Security, tenancy, and observability

Add global security:

security:
  - bearerAuth: []


Document tenant scoping:

Header X-Tenant-Id (or derived from JWT).

Every list endpoint MUST be tenant-scoped.

Add audit & webhooks:

/api/audit/events (paged)

/api/webhooks + events: quotation.accepted, booking.created, invoice.paid, payment.failed

Rate limiting headers for fairness: X-RateLimit-Limit, X-RateLimit-Remaining.

8) Quotation details & itinerary generation

POST /api/quotations should accept structured items (room nights, transfers, activities) not only metadata; otherwise totals aren’t reproducible.

Add:

QuotationItem:
  type: object
  required: [supplier_type, supplier_id, qty, unit_price]
  properties:
    supplier_type: { type: string, enum: [hotel, transfer, guide, restaurant, entrance_fee, extra_expense, tour_package] }
    supplier_id: { type: integer }
    date: { type: string, format: date, nullable: true }
    qty: { type: number }
    unit_price: { $ref: '#/components/schemas/Money' }
    notes: { type: string, nullable: true }


POST /api/quotations/{id}/generate-itinerary should return a concrete itinerary object with day-by-day items and keep a revision history. Include a 202 Accepted variant if generation is async.

9) Errors & validation

Replace ad-hoc Error with Problem (RFC 7807).

Include 422 Unprocessable Entity with field_errors: [{field, code, message}] for validation.

10) Consistency nits to fix now

Many list endpoints accept ad-hoc filters; align names across resources (status, city, language, tour_type) and add search.

Guide, Vehicle, Transfer, ExtraExpense schemas include organization_id; Provider and Hotel don’t—standardize.

Some update/delete ops take id in body; move to path params (/{id}) for REST hygiene.

Use ISO date-times (date-time) for created/updated timestamps; add them uniformly.

Minimal example of a corrected pattern (receivable payments)
/api/invoices/receivable/{id}/payments:
  post:
    summary: Record a payment against a receivable invoice
    headers:
      Idempotency-Key:
        $ref: '#/components/headers/IdempotencyKey'
    requestBody:
      required: true
      content:
        application/json:
          schema:
            type: object
            required: [amount, paid_date, method]
            properties:
              amount: { $ref: '#/components/schemas/Money' }
              paid_date: { type: string, format: date }
              method: { type: string, enum: [bank_transfer, card, cash] }
              reference: { type: string }
    responses:
      '201':
        description: Payment recorded
      '409':
        description: Overpayment or closed invoice
        content: { application/json: { schema: { $ref: '#/components/schemas/Problem' }}}

Suggested new endpoints (to close the lifecycle)

/api/bookings (see above)

/api/payments (list + details for both receivable/payable)

/api/finance/pnl (date range, by city/provider/customer, uses locked FX on bookings)

/api/attachments (store PDFs, vouchers, invoices)

/api/customers & /api/requests (your “Customer Requests” mention exists in info but not in paths)

Testing & governance

Add examples for each request/response.

Add JSON Schema $schema examples for Money, Problem, QuotationItem.

Validate spec with CI (spectral + openapi-cli).

Versioning: keep servers.url and add info.version: 1.1.0 when these changes land; consider prefixing paths with /api/v1/….

Quick win checklist (do these first)

 Add global security: bearerAuth, tenant header note.

 Introduce Money, Problem, PagedResponse, and pagination parameters.

 Convert all POSTs to 201 and return created resource; move id from body to /{id} for update/delete.

 Switch update routes to PATCH.

 Require Idempotency-Key for POSTs that create side-effects.

 Add /api/bookings and /api/finance/exchange-rates + document FX locking on acceptance.

 Normalize supplier/provider relationship; make provider_id required where possible.

 Add search param consistently.

 Add created_at, updated_at everywhere; make list endpoints sortable.